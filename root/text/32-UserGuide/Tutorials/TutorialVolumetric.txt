/**

\page TutorialVolumetric Volumetric data and 3D plots

In this tutorial you will explore options for extracting three-dimensional (3D) information from a simulated SKIRT
model. You will use the output of a simple spiral galaxy simulation to produce volume- or mass-weighted temperature
histograms and fully 3D temperature maps.

\section TutorialVolumetricPre Getting ready

This tutorial assumes that you have completed the introductory SKIRT tutorials \ref TutorialBasicsMono and \ref
TutorialBasicsPan, and that you have reviewed the topics on \ref UserVisualize and \ref UserProbes, or that you have
otherwise acquired the working knowledge introduced there. At the very least, before starting this tutorial, you should
have installed the SKIRT code, and preferably also PTS and a FITS file viewer such as DS9 (see \ref InstallationGuide).

To avoid spending time creating yet another SKIRT parameter file from scratch, this tutorial offers a \em ski file for
download to serve as an initial configuration. Download the file \c TutorialVolumetricSpiral.ski using the link
provided in the table below and put it into your local working directory.

<TABLE>
<TR><TH>Initial SKIRT parameter file</TH>
  <TD><a href="https://sciences.ugent.be/skirtextdat/SKIRTC/Tutorials/TutorialVolumetricSpiral.ski">TutorialVolumetricSpiral.ski</a>
  </TD>
</TABLE>

\section TutorialVolumetricIntro Introduction

SKIRT simulations usually produce output through both instruments and probes. Instruments mimic the observation of
radiation as projected on a plane. The output is therefore limited to two dimensions by definition. In contrast, probes
can peek inside the simulated model and provide information on various physical quantities, such as the medium density
or temperature. Because a probe has access to the full model, the output can take various forms, including arbitrary
planar cuts or projections. Interestingly, a probe can also be configured to output information for each cell in the
simulation's spatial grid, providing 3D data on the model. That is the topic of this tutorial.

There is an important caveat, however. The techniques discussed here only apply to quantities that are discretized on
the internal spatial grid used for the radiative transfer simulations. Essentially, this includes all medium
properties, whether derived (resampled) from the input model (e.g., density, velocity) or calculated in the simulation
(e.g., radiation field, dust temperature). However, it does \em not include the properties of the primary sources
(e.g., luminosity density), because these are never discretized on the internal spatial grid. Instead, the emitted
photon packets are sampled directly from the original (possibly imported) definition of the primary sources.


\section TutorialVolumetricModel The simulation model

Rename the downloaded SKIRT parameter file to a shorter name of your liking ending with the ".ski" filename extension,
for example \c volume.ski. Open the \em ski file in a text editor and examine its contents. You should recognize the
following configuration elements (not in this order):

 - a panchromatic simulation including dust emission, with wavelengths ranging from UV to sub-millimeter
    - the primary sources and the radiation field wavelength grid cover 0.09 to 100 micron
    - the dust emission wavelength grid covers 1 to 2000 micron
    - the instruments cover the full wavelength range from 0.09 to 2000 micron
 - a spatial geometry with four components:
    - a flattened SÃ©rsic bulge consisting of evolved stars (3500 K)
    - a thicker exponential disk consisting of evolved stars (3500 K), with spiral arm structure
    - a thinner exponential disk consisting of young stars (10000 K), with spiral arm structure
    - an exponential dust disk with spiral arm structure (the arms in the young stellar disk and the dust disk trail
      those in the evolved stellar population by varying the phase zero-points)
 - the material mix \c ThemisDustMix with support for stochastically heated dust grains in the dust emission calculation
 - an adaptive octree grid
 - two SED instruments at face-on and edge-on inclination, respectively
 - a fairly extensive list of probes
    - the standard convergence info and cuts probes, which allow a quick sanity check of the model
    - a temperature probe with the default cuts form, which produces temperature cuts in the same planes as the
      standard density cuts generated by the convergence cuts probe
    - a density probe and a temperature probe configured with the "per cell" form, which output the respective
      quantities for each cell in the spatial grid
    - the specialty "spatial cell properties" probe, which outputs basic information on each cell in the spatial grid,
      including the coordinates of the cell center and the cell volume, crucial for the purposes of this tutorial.

Run the \c volume.ski \em ski file with SKIRT. If SKIRT immediately produces a fatal error while constructing the
simulation, this probably means that the \em ski file needs upgrading; see \ref UserUpgradeSki.

Note the construction of the octree grid during setup. The total number of cells should be slightly over half a
million; the precise number depends on random sampling effects. Because the simulation includes dust emission and we
aim for a fairly well-resolved temperature distribution, the run time is a bit longer than usual for a tutorial.

After the simulation completes, open the convergence info file \c volume_cnv_convergence.dat in a text editor and
verify the statistics. The total dust mass should be accurately captured by the grid, with a discrepancy much smaller
than 1 per cent. The optical depth along the coordinate axes may show discrepancies of up to about 5 per cent. These
apparent inaccuracies are mostly a result of an implementation limitation in the spiral arm decorator: the
redistribution of the dust mass from the disk into the stellar arms is not properly accounted for in the listed input
optical depth.

Now use PTS to produce some standard plots and verify that the model behaves as expected. Because this is not the focus
of this tutorial, the plots below are reproduced with limited resolution.

\verbatim
pts plot_convergence .
\endverbatim

\image html TutorialVolumetricConvergenceCuts.png

\verbatim
pts plot_temperature .
\endverbatim

\image html TutorialVolumetricTemperatureCuts.png

\verbatim
pts plot_seds .
\endverbatim

\image html TutorialVolumetricSEDs.png


\section TutorialVolumetricHistograms Volumetric histograms

It is instructive to inspect the header information in the column text files produced by the "per cell" probes:

\verbatim
$ head -5 volume_prp_cellprops.dat
# column 1: spatial cell index (1)
# column 2: x coordinate of cell center (pc)
# column 3: y coordinate of cell center (pc)
# column 4: z coordinate of cell center (pc)
# column 5: cell volume (pc3)
\endverbatim

\verbatim
$ head -3 volume_tmp_dust_T.dat
# Indicative temperature per spatial cell
# column 1: spatial cell index (1)
# column 2: indicative temperature (K)
\endverbatim

The "spatial cell properties" probe outputs columns with the coordinates of the cell center and the volume for each
cell, plus some additional columns that are not of interest for this tutorial (but could be for other purposes). The
temperature probe configured with the "per cell" form simply outputs the indicative dust temperature for each cell.
Combining the information in both files allows obtaining 3D volumetric information.

The first column in each file lists an index that identifies the spatial cell represented by this row. In the current
implementation of the probes, there is always a row for each cell and the rows are representing the cells in the same
order. As a result, there is no need for explicit synchronization through the cell index.

You can now use Python to load and analyze these data. The code snippets shown below depend on at least some of the
previous snippets and thus should be entered sequentially. To work through the tutorial, you can copy each new code
section into a regular Python script and run the partially complete program from the start. Alternatively, you can copy
the code sections into a Python notebook so that you can run each section separately.

## Importing packages

\code{.py}
import numpy as np
import matplotlib.pyplot as plt
\endcode

At the start, import the Python packages used for handling the data and for plotting.

## Loading data

\code{.py}
x,y,z,V = np.loadtxt("volume_prp_cellprops.dat", usecols=(1,2,3,4), unpack=True)
rho = np.loadtxt("volume_dns_dust_rho.dat", usecols=1)
T = np.loadtxt("volume_tmp_dust_T.dat", usecols=1)
print(len(V), len(rho), len(T))
\endcode

Read the relevant columns into numpy arrays. Verify that all arrays have the same length, equal to the total number of
spatial cells listed in the log file.

## Basic analysis

To get a feel for the data, generate some basic histograms.

\code{.py}
plt.hist(np.log2(V**(1/3)), log=True, bins=100)
plt.show()
\endcode

\image html TutorialVolumetricVolumeHistogram.png

This plot shows that the cell volume distribution has a limited number of discrete values, and that those values differ
by a factor of \f$2^3\f$. This is as expected for an octree grid, where nodes are recursively subdivided into 8
subnodes until some termination criterion has been reached.

\code{.py}
plt.hist(T, log=True, bins=100)
plt.show()
\endcode

\image html TutorialVolumetricTemperatureHistogram.png

The indicative dust temperature values calculated by the simulation range from 11 to 45 K. Keep in mind that this plot
shows the temperature distribution of the spatial cells, regardless of their size. It thus heavily depends on the
discretization used in the simulation. See below for a histogram with a more appropriate physical interpretation.

There is also a significant number of cells with zero temperature. It turns out that these cells do no contain any
dust; this can be verified by removing the cells with zero density from the histogram (not shown here).

\code{.py}
plt.hist(np.log10(rho[rho>0]), log=True, bins=100)
plt.show()
\endcode

\image html TutorialVolumetricDensityHistogram.png

To allow showing the density on a logarithmic axis, this code removes empty cells before plotting the histogram. The
density values have a wide dynamic range of 7 orders of magnitude. Again, this plot shows the density distribution of
the spatial cells, regardless of their size and thus heavily depends on the discretization used in the simulation.

## Volumetric histograms

Now you can produce histograms with a more appropriate physical interpretation by combining information from the
various probes.

\code{.py}
mask = rho>0
plt.hist(T[mask], weights=V[mask], log=True, density=True, bins=100)
plt.hist(T[mask], histtype='step', log=True, density=True, bins=100)
plt.show()
\endcode

\image html TutorialVolumetricVolumeWeighted.png

This plot shows the volume-weighted temperature distribution (solid blue) versus the purely cell-based temperature
distribution considered in the previous paragraph (orange curve). Both distributions are normalized for ease of
comparison. Compared to the physically meaningful volume-weighted distribution, the cell-based distribution is
significantly shifted to higher temperatures. This indicates that higher-temperature regions are discretized with
smaller and thus more numerous cells.

\code{.py}
mask = rho>0
plt.hist(T[mask], weights=rho[mask]*V[mask], log=True, density=True, bins=100)
plt.hist(T[mask], histtype='step', log=True, density=True, bins=100)
plt.show()
\endcode

\image html TutorialVolumetricMassWeighted.png

This plot shows the mass-weighted temperature distribution (solid blue) versus the purely cell-based temperature
distribution (orange curve), again both normalized. The two distributions are surprisingly similar. This can be
understood by realizing that the octree subdivision criteria are designed to place a roughly equal amount of mass in
each cell.


\section TutorialVolumetric3Dmaps Three-dimensional maps

Using only a slightly more involved Python script, you can generate a simple 3D map of the indicative dust temperature
calculated by SKIRT for the model. The code snippet below assumes that Python packages have been imported and data have
been loaded in the same way as shown at the start of the previous section.

\code{.py}
fig = plt.figure(figsize=(10,10))
ax = plt.axes(projection="3d")
ax.view_init(35, 100)

mask = T>20
scatt = ax.scatter3D(x[mask], y[mask], z[mask], c=T[mask], cmap='OrRd', marker='8', s=1)

cbar = fig.colorbar(scatt, ax=ax, shrink=0.5, aspect=10)
cbar.set_label(r'$T\;[\mathrm{K}]$')

R = 8000
ax.set_xlim(-R, R)
ax.set_ylim(-R, R)
ax.set_zlim(-R, R)
ax.set_xlabel('X-axis [pc]')
ax.set_ylabel('Y-axis [pc]')
ax.set_zlabel('Z-axis [pc]')

plt.show()
\endcode

\image html TutorialVolumetricTemperatureMap.png

The low-temperature cut-off of 20 K causes the cells on the outskirts of the galaxy model to be omitted from the plot,
providing a clearer focus on the inside regions. You may want to study the effect of adjusting some of the hard-coded
values, including the temperature cutoff, the 3D inclination and azimuth, and the size of the axis box.

As shown here, the plot does not take into account the cell sizes. This can be mitigated by varying the size of the
markers (determined by the \c s argument) with the cell volume. However, for this example the effect is small because
the plot is mostly showing inner cells with comparable volumes. Also, in this plot, the high-temperature markers in the
center of the model are in part obscured by the surrounding lower-temperature markers. This can be mitigated by
constructing a color map that includes variable transparency, but that is outside the scope of this tutorial.


<b><i>Congratulations, you made it to the end of this tutorial!</i></b>

*/
